import React, { useEffect, useRef } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import Cookies from "universal-cookie";
import { instance } from "../api/api";
import LoadingSpinner from "../components/LoadingSpinner";
import { useQueryClient } from "react-query";

const cookies = new Cookies();

const OIDCAuthorization: React.FC = () => {
  // TODO: these values need to be parameterised in the application.
  const clientID = (import.meta as any).env.VITE_OIDC_CLIENT_ID;
  const redirectURI = new URL(window.location.href);
  redirectURI.search = "";
  const tokenURL = (import.meta as any).env.VITE_OIDC_OP_TOKEN_ENDPOINT;
  const navigate = useNavigate();
  const isFirstRender = useRef(true);
  const queryClient = useQueryClient();

  // Obtain the access token from the server.
  async function getAccessToken() {
    // We need to generate a Zitadel URL which asks it to log the user in.
    // The actual login process is described in the POC README.

    const url = new URL(window.location.href);
    const params = new URLSearchParams(url.search);

    // The code parameter is generated by Zitadel as a redirect. Because it's in the
    // URL, it's possible for it to be eavesdropped via MITM, OS and other attacks. So,
    // as the receiver, we need to verify to Zitadel that we are authorised to have the code.
    // And to do that, we use the random code challenge which was generated in the original
    // request. This ensures that only the browser that requested the access code can
    // convert it into an accessToken. This process is called "PKCE".
    // More info and a link to the RFC here:
    // https://zitadel.com/docs/guides/integrate/oauth-recommended-flows#our-recommended-authorization-flows
    const code = params.get("code") || "";
    // This is the code challenge we generated. Until this point, only we know the challenge, because
    // it was only sent as a hash during the code request. We are now going to send
    // it in the clear, to prove that we are the party who initiated the login flow.
    // Note: once we use the code, it can't be reused.
    let challengeString = sessionStorage.getItem("lotusCodeVerifier") || "";
    sessionStorage.removeItem("lotusCodeVerifier");

    // Now we put together and send a form to request the accessToken.
    const formData = new FormData();

    formData.append("grant_type", "authorization_code");
    formData.append("code", code);
    formData.append("redirect_uri", redirectURI.toString());
    formData.append("client_id", clientID);
    formData.append("code_verifier", challengeString);
    fetch(tokenURL, {
      method: "POST",
      body: formData,
    })
      .then((tokenResult) => tokenResult.json())
      .then((tokenObject) => {
        const accessToken = tokenObject.access_token;
        // only navigate to dashboard if authentication is valid
        if (accessToken) {
          sessionStorage.setItem("lotusAccessToken", accessToken);
          instance.defaults.headers.common[
            "Authorization"
          ] = `Bearer ${accessToken}`;
          queryClient.invalidateQueries("session").then(() => {
            navigate("/dashboard");
          });
        }
      })
      .catch((error) => {
        navigate("/login");
      });
  }

  useEffect(() => {
    getAccessToken();
  }, []);

  return (
    <div className="flex h-screen">
      <div className="m-auto">
        <LoadingSpinner />
      </div>
    </div>
  );
};

export default OIDCAuthorization;
