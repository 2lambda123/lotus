import React, { useEffect } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { toast } from "react-toastify";
import Cookies from "universal-cookie";
import { instance } from "../api/api";
import { useQueryClient, useMutation } from "react-query";

const cookies = new Cookies();

const OIDCAuthorization: React.FC<{ redirectTo?: string }> = ({
  redirectTo = "/dashboard",
}) => {
  // TODO: these values need to be parameterised in the application.
  const clientID = "196134552282923012@lotus";//(import.meta as any).env.ZITADEL_CLIENT_ID;
  const redirectURI = new URL(window.location.href);
  redirectURI.search = "";
  const tokenURL = "https://hello.uselotus.io/oauth/v2/token";
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const location = useLocation();

  // Obtain the access token from the server.
  async function getAccessToken() {
    // We need to generate a Zitadel URL which asks it to log the user in.
    // The actual login process is described in the POC README.
    
    const url = new URL(window.location.href);
    const params = new URLSearchParams(url.search);
    
    // The code parameter is generated by Zitadel as a redirect. Because it's in the
    // URL, it's possible for it to be eavesdropped via MITM, OS and other attacks. So,
    // as the receiver, we need to verify to Zitadel that we are authorised to have the code.
    // And to do that, we use the random code challenge which was generated in the original
    // request. This ensures that only the browser that requested the access code can
    // convert it into an accessToken. This process is called "PKCE".
    // More info and a link to the RFC here:
    // https://zitadel.com/docs/guides/integrate/oauth-recommended-flows#our-recommended-authorization-flows
    const code = params.get("code") || "";

    // This is the code challenge we generated. Until this point, only we know the challenge, because
    // it was only sent as a hash during the code request. We are now going to send
    // it in the clear, to prove that we are the party who initiated the login flow.
    // Note: once we use the code, it can't be reused.
    let challengeString = sessionStorage.getItem("lotusCodeVerifier") || "";
    sessionStorage.removeItem("lotusCodeVerifier");

    // Now we put together and send a form to request the accessToken.
    const formData = new FormData();

    formData.append("grant_type", "authorization_code");
    formData.append("code", code);
    formData.append("redirect_uri", redirectURI.toString());
    formData.append("client_id", clientID);
    formData.append("code_verifier", challengeString);
    const tokenResult = await fetch(tokenURL, {
      method: "POST",
      body: formData,
    });

    // Wait for the resulting token.
    // TODO: should redirect to the login page if there's an error.
    const tokenObject = await tokenResult.json();
    // Extract the access token and store it in session storage.
    // The access token will be used during API calls to prove that we are
    // who we say we are.
    const accessToken = tokenObject.access_token;
    sessionStorage.setItem("lotusAccessToken", accessToken);

    // Set the Redirect to the actual application.
    cookies.set("Bearer", accessToken);
    instance.defaults.headers.common["Authorization"] = `Bearer ${accessToken}`;
    queryClient.refetchQueries("session");
    navigate(redirectTo);
  }

  useEffect(() => {
    getAccessToken();
  }, []);

  return <div></div>;
};

export default OIDCAuthorization;
